# -*- coding: utf-8 -*-
"""SemLabExam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VUmUlaeU7yJs_TegoWEGS60rlqQxb7KZ
"""

print(type(False))

print(type("Anandu"))

t = False
r =  True

print(type(t!=r))

t = '''
  sfddsfdsfsdfdfsfdssfsdfffsfs
'''
print(type(t))

s = "hello"
s = s.capitalize()
s

# print(s.replace("o","1"))
s

print(" Android AlertDialog is the subclass of Dialog class".split())

t = [2,3,1]
print(f'"{t,t[2]}"')

print([t.append(x) for x in [10,7]])
print(t)
print(t[-1])

d= {"hai":1,"hello":2}
d.get("hai")
# d

iter = iter(d)
for i in d.keys():
  print(next(d))

def g(x):
  return x
s= 0
[s=s+x if x!=1 else g(x) for x in [1,2,3,4]]

class A:
  def __init__(self):
    print("new Object created")
  def fn(self,l=[1,2,3,4]):
    s =0
    for x in l:
      if l==1:
        s= x
      else:
        s= s+x  
    print(s)
a = A();
a.fn()

import numpy as np
l= [[1,2],[3,4],[6,7]]
a= np.array(l)
print(a)
a.shape



a[0][1] =5
print(a)
print(a[2,:])
a = a.T

print(a)
print(np.random.randint(low=3,high=4,size=a.shape))
r = np.random.random(a.shape)

c = np.array([[1,2],[1,2]])
print(c*c)
print(np.add(c,c),"=> add")
print(np.dot(c,c),"=> multiply elementwise")
print(c.dot(c),"=> multiply matrix")
t = np.array([[4,4],[4,4],[4,4],])
print(f'{np.sqrt(t)} => root of {t}')

# c.sum()
# t.reshape((2,3))
q = np.array([[0,2,3],
              [1,-2,3],
              [1,2,3]])
print(q)
# A = np.array([[6, 1, 1],
#               [4, -2, 5],
#               [2, 8, 7]])
  
# Calculating the inverse of the matrix
print(np.linalg.inv(q))
# print(np.linalg.inv(q))
print(np.linalg.eig(c))

# from numpy.core.fromnumeric import shape
print(t)
w = np.array([2,3])
# w.reshape(t[0].shape)
t+w

np.eye(2)

from numpy.linalg import svd
A = np.array([[1,2],[3,4],[5,6]])
U,s,VT = svd(A)
print(U)
print(s)
print(VT)

sigma = np.zeros(A.shape)
print(sigma)
# populate sigma with n*n diagonal matrix
print(np.diag(s))
print(sigma[:])
print(sigma[:A.shape[1],:A.shape[1]])
# sigma = np.diag(s)
sigma[:A.shape[1],:A.shape[1]] = np.diag(s)
print(s.shape)
print(sigma.shape)
print(VT.shape)
# reconstructing matrix A
print(U.dot(sigma.dot(VT)))



x = np.array([1,2,3])
v = np.array([4,5])
# x= x.reshape(3,1)
# v= v.reshape(2,1)
print(x.reshape((3,1)))
# print(v.reshape(2,1))
# x+v

import pandas as pd
series = pd.Series(["hai","hello"],index=["a","b"])
series

d = pd.DataFrame(series,columns=["words"])
d

d= pd.DataFrame({"words":{"a":"hai","b":"hello"}})
d

s1 = pd.DataFrame({ 'RollNo': ['S1', 'S2', 'S3', 'S4', 'S5'],
'name': ['Nirmal Fenton', 'Ryder Storey', 'Bryce Jensen', 'Nil Bernal', 'Kwame Morin'],
'age':[23,56,12,13,14], 'marks': [20, 210, 190, 222, 30]})
s1

s1[s1["marks"]<50]

s1[s1["name"].str.endswith('l')]

str2 = " hai , hello.\n hw r u ? "
str2.splitlines()

import matplotlib.pyplot as plt
x = np.arange(0,3*np.pi,0.1)
print(x)
y_sin= np.sin(x)
y_cos= np.cos(x)
# print(y)
plt.plot(x,y_cos)
plt.plot(x,y_sin)
plt.xlabel("x-axis")
plt.ylabel("y-axis")
plt.title("Sine and Cosine")
plt.legend(["sine","cosine"])
plt.show()

import numpy as np
# import matplotlib.pyplot as plt
# from scipy.misc import imread
img = plt.imread('./cat.jpg')
img_tinted = img * [1, 0.25, 0.9]
plt.subplot(1,2,1)
plt.imshow(img)
plt.subplot(1,2,2)
plt.imshow(np.uint32(img_tinted))
plt.show()

"""#KNN"""

from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
import pandas as pd
data = load_iris()
data.keys()
# for x in data.keys():
#   print(x)
#   print(data[x])
df = pd.DataFrame(data.data,columns=data.feature_names)
df["target"] = data.target
# print(df.head(5))
# print(df.tail(5))

xtrain,xtest,ytrain,ytest = train_test_split(df[data.feature_names],df["target"],random_state=42,test_size=0.1,)
# print("\ntraining data")
# print(xtrain,ytrain)
# print("\ntest data")
# print(xtest,ytest)
clf = KNeighborsClassifier()
clf.fit(xtrain,ytrain)
ypred = clf.predict(xtest)
print(ypred,"\n",ytest.sort_index())

# calculating accuracy
from sklearn.metrics import accuracy_score
print("Accuracy : ",accuracy_score(ytest,ypred,))

"""#Naive Baiyes"""

from pandas.io.formats.style_render import DataFrame
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score
data = load_iris()
X = data.data
Y = data.target
xtrain,xtest,ytrain,ytest = train_test_split(X,Y,random_state=42,test_size=0.1,)

gnb = GaussianNB()
gnb.fit(xtrain,ytrain)
ypred = gnb.predict(xtest)

# dsts = DataFrame({"Actual Value":[1,2,3]},{"Predicted Value":[1,2,3]})
# dsts = DataFrame([ytest,ypred])
# print(dsts)
print("accuracy = ",accuracy_score(ytest,ypred))

"""#Linear Regression"""

from sklearn.datasets import load_iris
from sklearn.linear_model import LinearRegression
x = [[0, 1], [5, 1], [15, 2], [25, 5], [35, 11], [45, 15], [55, 34], [60, 35]]
y = [4, 5, 20, 14, 32, 22, 38,43]
model = LinearRegression().fit(x,y)
print("Coeffient of determination : ",model.score(x,y))
print("intercept : ",model.intercept_)
print("coeffients : ",model.coef_)
ypred = model.predict(x)
print("\nPredicted output : ",ypred)

import requests
from bs4 import BeautifulSoup
r = requests.get("https://www.javatpoint.com/machine-learning-support-vector-machine-algorithm")
soup = BeautifulSoup(r.content,'html5lib')
# print(soup)
# print([x for x in soup.prettify().split('<') if 'img' in x])
images = soup.findAll('img')
for image in images:
    # if image:
    #     print(image.split(" "))
    if len(str(image).split())>4:
      print(str(image).split()[5])
    # Print image source
    # print(image['src'])
    # Print alternate text
    # print(image['alt'])

!apt install libasound2-dev portaudio19-dev libportaudio2 libportaudiocpp0 ffmpeg

!pip install pyAudio

from io import BytesIO
from base64 import b64decode
from google.colab import output
from IPython.display import Javascript

RECORD = """
const sleep  = time => new Promise(resolve => setTimeout(resolve, time))
const b2text = blob => new Promise(resolve => {
  const reader = new FileReader()
  reader.onloadend = e => resolve(e.srcElement.result)
  reader.readAsDataURL(blob)
})
var record = time => new Promise(async resolve => {
  stream = await navigator.mediaDevices.getUserMedia({ audio: true })
  recorder = new MediaRecorder(stream)
  chunks = []
  recorder.ondataavailable = e => chunks.push(e.data)
  recorder.start()
  await sleep(time)
  recorder.onstop = async ()=>{
    blob = new Blob(chunks)
    text = await b2text(blob)
    resolve(text)
  }
  recorder.stop()
})
"""

def record(sec=3):
  print("Speak Now...")
  display(Javascript(RECORD))
  sec += 1
  s = output.eval_js('record(%d)' % (sec*1000))
  print("Done Recording !")
  b = b64decode(s.split(',')[1])
  return b #byte stream
record()

import speech_recognition as sr

def recognize_speech_from_mic(recognizer, microphone):
    """Transcribe speech from recorded from `microphone`.

    Returns a dictionary with three keys:
    "success": a boolean indicating whether or not the API request was
               successful
    "error":   `None` if no error occured, otherwise a string containing
               an error message if the API could not be reached or
               speech was unrecognizable
    "transcription": `None` if speech could not be transcribed,
               otherwise a string containing the transcribed text
    """
    # check that recognizer and microphone arguments are appropriate type
    if not isinstance(recognizer, sr.Recognizer):
        raise TypeError("`recognizer` must be `Recognizer` instance")

    if not isinstance(microphone, sr.Microphone):
        raise TypeError("`microphone` must be `Microphone` instance")

    # adjust the recognizer sensitivity to ambient noise and record audio
    # from the microphone
    with microphone as source:
        print("adjust_for_ambient_noise ..")
        recognizer.adjust_for_ambient_noise(source)
        print("Listening to audio ..")
        audio = recognizer.listen(source,1000)

    # set up the response object
    response = {
        "success": True,
        "error": None,
        "transcription": None
    }

    # try recognizing the speech in the recording
    # if a RequestError or UnknownValueError exception is caught,
    #     update the response object accordingly
    try:
        print("Listening ....")
        response["transcription"] = recognizer.recognize_google(audio)
    except sr.RequestError:
        # API was unreachable or unresponsive
        response["success"] = False
        response["error"] = "API unavailable"
    except sr.UnknownValueError:
        # speech was unintelligible
        response["error"] = "Unable to recognize speech"

    return response

if __name__ == "__main__":
    # create recognizer and microphone instances
    
    recognizer = sr.Recognizer()
    # microphone = record()
    microphone = sr.Microphone()

    # get audio from the microphone
    response = recognize_speech_from_mic(recognizer, microphone)

    # if the response is successful, print the transcription
    if response["success"]:
        print(response["transcription"])
    else:
        print(response["error"])

"""#Decision Tree"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

ir = load_iris()
x = ir.data
y = ir.target
xtrain,xtest,ytrain,ytest = train_test_split(x,y,random_state=42,test_size=0.1)
model = DecisionTreeClassifier()
model.fit(xtrain,ytrain)
print(model.get_depth())
print(model.get_n_leaves())
ypred = model.predict(xtest)
# [x for x in ypred if x in ytest]
accuracy_score(ytest,ypred)

"""#KMeans"""

from sklearn.cluster import KMeans
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_iris
import matplotlib.pyplot as plt
import pandas as pd
# ir = load_iris()
x= ir.data
y= ir.target
# plt.plot(x,y)
# print(pd.read_csv('./sample_data/california_housing_train.csv'))
print(ir.feature_names)
xtrain,xtest,ytrain,ytest = train_test_split(x,y,random_state=42,test_size=0.1)

model = KMeans()
model.fit(xtrain[:,:1],ytest)
ypred = model.predict(xtest[:,:1])
# print(xtrain[:,0])
# print(ytest,ypred)
accuracy_score(ytest,ypred)